# Development Guidelines (English Version, Updated)

## Philosophy

### Core Beliefs

* **Incremental progress over big bangs**: Make small iterations that compile and pass tests
* **Learn from existing code**: Study, analyze, and plan before implementation
* **Pragmatic over dogmatic**: Adapt solutions to real project needs
* **Clear intent over clever code**: Prefer simple, readable solutions over clever tricks

### What Simplicity Means

* Each function/class should have a single responsibility
* Avoid premature abstraction
* Use straightforward solutions; avoid unnecessary cleverness
* If the solution requires explanation, it might be too complex

---

## Process

### 1. Planning & Stage Breakdown

Break complex work into 3–5 stages. **Optional**: stage plans can be recorded in internal notes or a central document; **automatic creation of `IMPLEMENTATION_PLAN.md` is not required**.

* **Example format (for reference only)**:

  ```text
  Stage N: [Name]
  Goal: [Specific deliverable]
  Success Criteria: [Testable outcomes]
  Tests: [Specific test cases]
  Status: [Not Started|In Progress|Complete]
  ```

* Update stage status as you progress; no file is automatically generated

---

### 2. Implementation Flow

1. **Understand**: Review existing code patterns in the codebase
2. **Test first**: Write failing tests (red)
3. **Implement**: Write minimal code to pass tests (green)
4. **Refactor**: Clean up while keeping all tests passing
5. **Commit**: Use clear commit messages; optionally reference stage plan

---

### 3. When Stuck (Maximum 3 Attempts)

1. **Document failures**:

   * What was tried
   * Error messages
   * Reason for failure

2. **Research alternatives**:

   * Identify 2–3 similar implementations
   * Note differences in approach

3. **Question fundamentals**:

   * Is this the right abstraction level?
   * Can it be broken into smaller problems?
   * Is there a simpler solution?

4. **Try a different angle**:

   * Use a different library or framework feature
   * Consider an alternative architectural pattern
   * Reduce abstraction instead of adding more

---

## Technical Standards

### Architecture Principles

* **Composition over inheritance**: Prefer dependency injection
* **Interfaces over singletons**: Improve testability and flexibility
* **Explicit over implicit**: Make data flow and dependencies clear
* **Test-driven when possible**: Never disable tests

### Code Quality

* **Every commit must**:

  * Compile successfully
  * Pass all existing tests
  * Include tests for new functionality
  * Follow formatting and lint rules

* **Before committing**:

  * Run formatters and linters
  * Self-review changes
  * Ensure commit message explains the “why”

### Error Handling

* Fail fast with descriptive messages
* Include sufficient context for debugging
* Handle errors at the appropriate level
* Never silently swallow exceptions

---

## Decision Framework

When multiple valid approaches exist, prioritize:

1. **Testability**
2. **Readability** (should be understandable in 6 months)
3. **Consistency** (matches project conventions)
4. **Simplicity**
5. **Reversibility** (ease of future modification)

---

## Project Integration

### Learning the Codebase

* Identify 3 similar features/components
* Recognize common patterns and conventions
* Reuse existing libraries and utilities when possible
* Follow existing test patterns

### Tooling

* Use existing build systems, test frameworks, and formatters/lint rules
* Avoid introducing new tools unless strongly justified

---

## Quality Gates

### Definition of Done

* [ ] Tests written and passing
* [ ] Code follows project conventions
* [ ] No linter/formatter warnings
* [ ] Commit messages are clear
* [ ] Implementation matches plan
* [ ] No TODOs without linked issue numbers

### Test Guidelines

* Test behavior, not implementation details
* Prefer one assertion per test where possible
* Test names clearly describe scenarios
* Use existing test utilities/helpers
* Tests should be deterministic

---

## Important Reminders

**NEVER**:

* Use `--no-verify` to bypass commit hooks
* Disable tests instead of fixing them
* Commit code that does not compile
* Make assumptions; always verify with existing code

**ALWAYS**:

* Commit working code incrementally
* Update stage plan as you progress (optional, internal notes only)
* Learn from existing implementations
* Stop after 3 failed attempts and reassess
* Document thought process and results in  Chinese

---

✅ **Key Updates**:

* Removed automatic creation of `IMPLEMENTATION_PLAN.md`
* Stage planning is optional and can be recorded internally
* Core processes, standards, and quality gates remain unchanged


---
alwaysApply: true
---
