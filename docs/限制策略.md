# 📘 **《短信取件码助手 —— 免费版/专业版策略开发需求文档》**

## 1. 版本说明

* 免费版 = App 默认状态
* 专业版 = 用户完成“设备激活”后解锁
* 激活方式：用户输入有效激活码（你本地 Python 脚本生成）

---

# 2. 限制策略实现（核心）

## 2.1 自动识别短信

| 项    | 免费版 | 专业版 |
| ---- | --- | --- |
| 自动识别 | 开启  | 开启  |
| 逻辑差异 | 无   | 无   |

开发说明：

* 自动识别逻辑保持一致
* 区别体现在**识别频率、速度、记录数量**上

---

## 2.2 识别速度策略

**免费版**

* 解析短信 → 延迟 `1000ms` 后再返回结果
* 不影响识别精度

**专业版**

* 无延迟，直接返回结果

开发说明（伪代码）：

```ts
if user.isActivated:
    return parseSms()
else:
    await sleep(1000)
    return parseSms()
```

---

## 2.3 每日识别次数限制

**免费版：**

* 每天最多识别短信 **5 次**

**专业版：**

* 无限次

开发说明：

### 数据需要持久化：

```
key: identify_count_<date>
value: 当天已识别次数
```

### 逻辑：

```ts
if !user.isActivated:
    if identify_count >= 5:
        showDialog("免费版每天可识别 5 次，请激活以解锁无限次数。")
        return
```

---

## 2.4 历史记录条数限制

**免费版：最多 3 条记录**

* 每次新增记录时，如果超过 3 条 → 删除最早一条

**专业版：无限制**

开发说明（伪代码）：

```ts
if !user.isActivated:
    if history.length >= 3:
        history.removeOldest()
history.add(newItem)
```

数据库结构保持不变。

---

## 2.5 高精度识别模型（可选项，若你有两套规则可用）

* 免费版使用普通规则解析
* 专业版使用更加严格/丰富的短信解析规则

如没有两套规则，可忽略。

---

# 3. 激活系统需求

## 3.1 获取设备 ID

* 设置页展示设备ID
* 点击可复制

格式可固定为：

```
Android + 设备指纹 + 安装时间Hash
```

---

## 3.2 输入激活码页面

字段：

* 输入框：激活码
* 按钮：提交

流程：

1. 用户输入激活码
2. App 调用本地校验逻辑
3. 校验通过 → `user.isActivated = true` → 保存本地
4. 关闭限制策略

---

## 3.3 激活码校验

App 端需要一个校验算法（你已有 Python 生成部分）

开发需要你提供：

* 校验算法（或你提供 JS 版本）
* 激活码格式（长度、字符集）

---

# 4. UI 文案说明（程序员直接使用）

## 免费版被限制时提示

**识别次数达到限制：**

> 今日已使用 5 次免费识别。
> 激活后可享受无限识别。

**历史记录满：**

> 免费版最多保留 3 条记录。
> 激活后可保存全部记录。

**识别延迟无需提示（后台处理）**

---

# 5. 设置页面新增入口要求

设置页面新增模块：

```
[设备激活]
- 查看设备ID
- 复制ID
- 输入激活码
- 激活按钮
```

以及进入 activate.html 的按钮：

```
前往激活页面
```

文案示例：

> 一次设备激活，永久使用专业功能（绑定设备 ID）

---

# 6. 安全需求

* 所有激活判断基于本地存储
* 不需要联网
* 避免在日志中打印激活信息

---

# 📌 最终验证说明（给程序员）

完成开发后需验证：

1. 免费版识别超过 5 次是否被正确拦截
2. 免费版历史记录是否限制在 3 条
3. 免费版短信识别是否存在 1 秒延迟
4. 激活码输入正确后是否立即解锁全部功能
5. 设置页激活入口是否可用
6. 卸载重装后激活状态是否保持（或按你需求决定）

