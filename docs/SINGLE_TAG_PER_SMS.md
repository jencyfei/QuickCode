# 单标签规则实现

## 📋 需求

**问题**: 同一条短信会被打上两个标签  
**要求**: 一条短信只能打一个标签

## ✅ 实施方案

### 1. 修改分类逻辑

**文件**: `backend/app/services/sms_classifier.py`

**修改内容**:
- 将标签匹配逻辑从"可能匹配多个"改为"只返回一个"
- 按优先级顺序判断，找到第一个匹配的标签就返回

**标签优先级**:
```
1. 验证码（最高优先级）
2. 快递
3. 银行
4. 通知
5. 营销（最低优先级）
```

**修改前**:
```python
def classify(cls, content: str, sender: str = '') -> Set[str]:
    tags = set()
    
    if cls._is_verification_code(content_lower, sender_lower):
        tags.add('验证码')
        return tags
    
    if cls._is_express(content_lower, sender_lower):
        tags.add('快递')
    
    if cls._is_bank(content_lower, sender_lower):
        tags.add('银行')
    
    # ... 可能返回多个标签
    return tags
```

**修改后**:
```python
def classify(cls, content: str, sender: str = '') -> Set[str]:
    content_lower = content.lower()
    sender_lower = sender.lower()
    
    # 优先级1: 验证码
    if cls._is_verification_code(content_lower, sender_lower):
        return {'验证码'}
    
    # 优先级2: 快递
    if cls._is_express(content_lower, sender_lower):
        return {'快递'}
    
    # 优先级3: 银行
    if cls._is_bank(content_lower, sender_lower):
        return {'银行'}
    
    # 优先级4: 通知
    if cls._is_notification(content_lower, sender_lower):
        return {'通知'}
    
    # 优先级5: 营销
    if cls._is_marketing(content_lower, sender_lower):
        return {'营销'}
    
    # 无法分类
    return set()
```

### 2. 清理历史数据

**文件**: `backend/clean_duplicate_tags.py`

**功能**:
- 扫描所有有多个标签的短信
- 按优先级保留一个标签
- 删除其他标签关联

**使用方法**:
```bash
cd backend
python clean_duplicate_tags.py
```

**输出示例**:
```
=== 清理重复标签 ===

发现 5 条短信有多个标签

短信 ID: 123
  发件人: 95533
  内容: 【建设银行】您的验证码是123456...
  当前标签: 验证码, 银行
  保留: 验证码
  删除: 银行
  ✅ 已清理

=== 清理完成 ===
处理短信数: 5
删除标签关联数: 5
✅ 现在每条短信只有一个标签
```

## 🎯 优先级设计理由

### 1. 验证码（最高）
**原因**: 
- 验证码是最明确的类型
- 通常不会与其他类型混淆
- 用户最关心的是验证码本身

**示例**:
```
【建设银行】您的验证码是123456
→ 标签: 验证码（而不是银行）
```

### 2. 快递
**原因**:
- 快递信息时效性强
- 用户需要及时取件
- 快递通知通常很明确

**示例**:
```
【菜鸟驿站】您的快递已到达，取件码：1234
→ 标签: 快递
```

### 3. 银行
**原因**:
- 涉及资金安全
- 重要性高
- 需要单独管理

**示例**:
```
【建设银行】您尾号1234的卡消费100元
→ 标签: 银行
```

### 4. 通知
**原因**:
- 通用性较强
- 可能与其他类型重叠
- 优先级相对较低

**示例**:
```
【系统通知】您的订单已发货
→ 标签: 通知
```

### 5. 营销（最低）
**原因**:
- 通常不紧急
- 可能包含多种信息
- 优先级最低

**示例**:
```
【商城】双11大促，全场5折起
→ 标签: 营销
```

## 📊 影响分析

### 对新短信的影响

**修改前**:
```
短信: "【建设银行】您的验证码是123456，请勿泄露"
标签: 验证码, 银行
```

**修改后**:
```
短信: "【建设银行】您的验证码是123456，请勿泄露"
标签: 验证码
```

### 对已有短信的影响

需要运行清理脚本：
```bash
python clean_duplicate_tags.py
```

清理后：
- 每条短信只保留一个标签
- 按优先级选择保留哪个标签
- 标签统计数量会减少

## 🧪 测试用例

### 测试1: 验证码优先

**输入**:
```
内容: "【建设银行】您的验证码是123456"
发件人: "95533"
```

**预期**:
```
标签: 验证码（不是银行）
```

### 测试2: 快递优先

**输入**:
```
内容: "【菜鸟驿站】您有快递到达，请及时领取，优惠活动进行中"
发件人: "菜鸟"
```

**预期**:
```
标签: 快递（不是营销）
```

### 测试3: 银行优先

**输入**:
```
内容: "【招商银行】温馨提醒：您的信用卡账单已出，请及时还款"
发件人: "95555"
```

**预期**:
```
标签: 银行（不是通知）
```

### 测试4: 纯验证码

**输入**:
```
内容: "您的验证码是654321，5分钟内有效"
发件人: "106xxx"
```

**预期**:
```
标签: 验证码
```

### 测试5: 纯营销

**输入**:
```
内容: "双11大促，全场5折，快来抢购"
发件人: "商城"
```

**预期**:
```
标签: 营销
```

## 🔧 实施步骤

### 步骤1: 备份数据（可选）

```bash
# 备份数据库
pg_dump sms_agent > backup_before_cleanup.sql
```

### 步骤2: 更新代码

代码已更新：
- ✅ `backend/app/services/sms_classifier.py`
- ✅ `backend/clean_duplicate_tags.py`

### 步骤3: 重启后端服务

```bash
# 停止后端
Ctrl+C

# 重新启动
cd backend
uvicorn app.main:app --reload --port 10043
```

或使用启动脚本：
```bash
start_backend.bat
```

### 步骤4: 清理历史数据

```bash
cd backend
python clean_duplicate_tags.py
```

### 步骤5: 验证结果

1. **检查新短信**
   - 导入新短信
   - 查看是否只有一个标签

2. **检查已有短信**
   - 查看标签管理页面
   - 确认每条短信只有一个标签

3. **检查标签统计**
   - 标签数量应该正确
   - 不应该有重复计数

## 📝 注意事项

### 1. 优先级调整

如果需要调整优先级，修改 `sms_classifier.py` 中的判断顺序：

```python
# 例如：将银行优先级提高到快递之前
if cls._is_bank(content_lower, sender_lower):
    return {'银行'}

if cls._is_express(content_lower, sender_lower):
    return {'快递'}
```

### 2. 添加新标签类型

如果要添加新的标签类型：

1. 在 `SmsClassifier` 中添加关键词
2. 添加判断方法
3. 在 `classify` 方法中添加判断逻辑
4. 确定优先级位置

### 3. 特殊情况处理

**情况1**: 短信确实属于多个类型

**解决**: 按优先级选择最重要的类型

**情况2**: 用户想手动添加多个标签

**解决**: 
- 自动分类只添加一个标签
- 用户可以手动添加其他标签
- 但建议保持单标签规则

## 🎉 总结

### 修改内容

1. ✅ 修改分类逻辑，确保只返回一个标签
2. ✅ 定义标签优先级顺序
3. ✅ 创建清理脚本处理历史数据
4. ✅ 添加验证功能

### 效果

- ✅ 新短信只会被打一个标签
- ✅ 已有短信可以通过脚本清理
- ✅ 标签统计更准确
- ✅ 用户体验更清晰

### 优势

- **清晰**: 每条短信只有一个明确的分类
- **准确**: 按优先级选择最合适的标签
- **高效**: 减少标签冗余
- **易维护**: 逻辑简单明了

---

**实施状态**: ✅ 已完成  
**测试状态**: ⏳ 待测试  
**清理状态**: ⏳ 待执行清理脚本  
**文档状态**: ✅ 完整  
