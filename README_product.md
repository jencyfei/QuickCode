## 项目总览：SMS Agent – 让取件码不再难找的短信助手

`SMS Agent` 是一款专注于「快递取件码识别与管理」的 Android 应用。  
它会在本机短信中自动识别快递通知，提取取件码、站点地址和时间信息，用一个更直观的界面替代传统短信列表，让你在驿站排队时不再手忙脚乱地翻 106 开头的长短信。

从定位上看，`SMS Agent` 不是一个“大而全”的短信 App，而是一款**极致聚焦在“快递取件效率 + 信息可视化”的轻量工具**。

---

## 目标用户与关键场景

### 目标用户

- **网购重度用户**：一天到晚各种快递通知，取件码短信铺天盖地。
- **代收/集中取件场景**：前台、宿舍楼管、门卫等需要频繁帮人取件的人群。
- **家庭/团队“快递管家”**：经常帮家人或同事统一取件的人。

### 使用场景

- 到驿站排队时，才开始翻短信找「您的快递已到××驿站，取件码 XXXX」。
- 短信太多，只记得是“菜鸟驿站”，却怎么也翻不到那条通知。
- 想回顾最近一段时间的快递记录（有没有漏取？有没有错拿？），但系统短信应用既难找又难看。

`SMS Agent` 的设计目标，就是在这些真实场景下，**把找取件码的时间压缩到几秒以内**。

---

## 产品核心卖点（售前视角）

- **更快找到取件码**：  
  打开 App 即自动识别本机短信，聚焦展示快递通知和取件码，不再被各种营销短信淹没。

- **按“未取 / 已取”管理快递**：  
  快递被分成「未取快递」和「已取快递」两大类，  
  一眼看出：**还有多少没取？今天的都取完了吗？**

- **按时间 + 地址智能分组**：  
  - 按日期、月份进行归类显示；  
  - 同一驿站/站点的多条快递合并在一起展示，更贴近真实使用场景；  
  - 对“经常在同一个驿站取很多件”的用户尤其友好。

- **批量操作，高频场景提效**：  
  - 批量复制当前时间窗口内的未取取件码，到驿站出示一屏搞定；  
  - 一键将当前展示的未取快递标记为已取，形成自己的“快递清单”。

- **为“不卡”做了大量底层优化**：  
  针对「打开快递页要等 2–3 秒」的问题，做了多轮性能优化与懒加载设计，  
  中低端机型也能保持较为流畅的体验。

- **隐私友好，完全本地识别**：  
  所有识别逻辑都在本地完成，不上传短信内容到服务器。

---

## 主要功能模块

### 快递列表（ExpressScreen）

**定位：** 产品的核心价值承载页。

- 自动从短信中识别快递信息：
  - 快递公司、取件码、站点/地址、接收时间等；
  - 通过规则引擎从运营商类短信中提取结构化快递数据。
- 「未取 / 已取」双标签页：
  - 未取：重点展示近期还未取走的快递；
  - 已取：适合回顾、核对和历史查询。
- 展示特点：
  - 按日期分组，在组内再按收货地址分组；
  - 搜索取件码或日期，快速定位某一次快递。

### 批量能力与一键操作

- **批量复制取件码**：  
  在「未取」页签中，一键复制当前时间窗口内所有未取快递的取件码，  
  适合排队前提前准备，一次出示多个取件码。

- **一键标记已取**：  
  将当前展示的未取快递，一键全部标记为已取；  
  状态通过本地存储持久化，重启应用后仍然保持。

### 短信列表视图（SmsListScreen）

**定位：** 为“回看短信原文 / 检查识别情况”提供一个轻量入口。

- 默认只展示最近一段时间内的短信（如近 90 天，可配置）；  
- 支持根据短信内容或发件人搜索，快速查找某条通知或验证码；  
- 使用懒加载技术，向下滑动再加载更多，避免一次性加载过多短信造成卡顿。

### 时间窗口配置（TimeWindowSettings）

**目标：** 在“速度”和“完整性”之间给用户一个可调节的平衡点。

- **快递展示范围**：近 30 / 60 / 90 天可选；  
- **短信展示范围**：近 90 / 120 / 180 天可选。  

页面上会有清晰的文案提示当前展示的是“最近 N 天数据”，并提供“加载更多历史”入口，  
用户可以在需要时再扩展时间窗口，而不是一上来就把所有历史都加载出来。

---

## 性能与体验优化亮点

### 数据读取范围控制

- 对短信数据库读取设置上限，避免一次性把所有历史短信读入内存：
  - 已激活用户：默认读取最多约 5000 条；
  - 默认/体验模式：最多约 50000 条，兼顾完整性和性能。
- 用户感知：
  - 首次打开快递页面的等待时间更短，更可预测；
  - 即使短信非常多，也不会明显拖慢整机体验。

### 缓存机制与增量更新

- 内置缓存对象：
  - `ExpressDataCache`：缓存已解析的快递列表；
  - `SmsListCache`：缓存用于展示的短信列表。
- 利用最近一条短信的 `_ID` + 时间戳判断缓存是否仍然“新鲜”；  
- 若短信数据库无变化，则直接使用缓存，避免重复扫描全量短信；  
- 若检测到有新短信，则仅读取“新增部分”，对快递数据执行增量识别并合并去重。

### 懒加载与分段展示

- **短信列表**：  
  - 后端分页拉取，前端再基于 `LazyColumn` 做本地分页展示；  
  - 首屏只渲染一定数量短信，滑动到接近底部时再加载下一批。

- **快递列表**：  
  - 按月份进行分段展示，每个月可以折叠/展开；  
  - 默认只展开最近 1–2 个月，其余月份折叠时内部完全不渲染，真正做到“看不见就不算数”；  
  - 在此基础上，再按日期和地址层层分组，兼顾信息结构与性能。

### 日志控制与问题排查开关

- 内置 `AppLogger` 日志组件和 `LogControlSettings` 配置：  
  - 正常使用时只输出少量关键日志，降低 I/O 占用；  
  - 需要排查问题时，可以在设置里打开“诊断日志”开关，自动输出更详细的调试信息；  
  - 通过 `AppLogger.debug { ... }` 懒计算形式，避免在关闭日志时仍然做大量字符串拼接。

---

## 隐私与安全设计

- **本地处理优先**：  
  所有短信读取、快递识别和内容解析都在本机完成，不上传到云端。

- **最小权限原则**：  
  只请求与核心功能直接相关的短信读取权限，不额外索取通讯录、定位、相册等高敏感权限。

- **诊断信息可控**：  
  日志默认精简；  
  只有在用户主动打开“诊断日志”开关时，才会记录更多脱敏信息用于分析问题。

从售前/宣传角度，可以对用户清晰传达：  
**“这是一款只在你手机本地帮你整理短信的工具，不会把内容传到云端。”**

---

## 用户使用流程（可改写成小红书文案结构）

1. **第一次打开 App**
   - 授权短信读取权限；
   - 阅读并同意隐私政策。

2. **查看未取快递**
   - 默认进入「未取快递」页签；
   - 自动看到最近 N 天内识别出来的所有未取件。

3. **排队取件前**
   - 点击顶部的「批量复制」，一次复制多条取件码；
   - 到柜机或窗口，一屏展示取件码即可。

4. **取完快递后**
   - 点击「一键标记已取」，把当前这些快递全部归类到“已取”；  
   - 形成自己的「快递完成记录」，后续可以随时翻查。

5. **想核对短信原文 / 检查有没有漏识别**
   - 打开「短信列表」页签；  
   - 通过搜索或时间窗口调整，查看原始短信内容。

---

## 技术栈与架构简述（方便给技术同事看的部分）

- **Android 端**：Kotlin + Jetpack Compose  
  使用 `Scaffold`、`LazyColumn`、`Surface`、`Card`、`Dialog` 等组件构建原生 UI。

- **数据访问层**：  
  通过 `SmsReader` 访问系统 `content://sms` 提供者；  
  使用基于时间戳 + `_ID` 的分页查询策略，避免 OFFSET 带来的性能和准确性问题。

- **配置与缓存**：  
  - `TimeWindowSettings` / `LogControlSettings` 使用 `SharedPreferences` 存储用户配置；  
  - `ExpressDataCache` / `SmsListCache` 负责缓存列表和最新短信元信息。

- **日志体系**：  
  `AppLogger` 封装了 Logcat 输出和可选文件输出，  
  并通过“诊断日志开关”与 Debug 构建配置联动，兼顾排错效率与运行性能。

---

## 小红书推文创作建议（基于本 README 二次创作）

你可以把这份文档当作「产品白皮书」，再用更生活化的方式改写成小红书推文，例如：

- 用痛点开头：  
  “每次排队取快递，都在短信里艰难翻找取件码？有时候翻半天都找不到那条‘菜鸟驿站’短信？”

- 用 1–2 张核心截图讲清楚是什么：  
  - 未取快递列表（清晰的取件码 + 站点 + 时间）；  
  - 批量复制 / 一键标记已取按钮。

- 用简单的话解释产品价值：  
  - “打开就能看到所有取件码”；  
  - “不用翻短信，不用担心漏取”；  
  - “短信只在本地分析，不上传 anywhere”。

- 适当加一点幕后故事：  
  例如为了让列表不卡，做了缓存、懒加载、增量读取等多轮优化，  
  既体现用心程度，也能增加技术可信度。

如需，我可以在这份 `README_product.md` 的基础上，帮你再写一份直接可发的小红书图文脚本。  


